<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>AOJLS: AOJLS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AOJLS
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">CJSONparsing/generatinglibrary</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">AOJLS </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>AOJLS - "All other JSON libraries suck" is JSON parsing/generating library that is not aiming for speed or efficiency, but instead aims for programmers comfort. With this in mind, AOJLS is built on these principles:</p>
<ol type="1">
<li>Creating simple and complex JSON values should be easy and intuitive</li>
<li>Programmer should not be bothered to track liveness of all JSON values manually</li>
<li>If there is any error when working with JSON values, it should be possible to defer error checking until next logical step</li>
</ol>
<p>To fulfill these principles, AOJLS employs these techniques:</p>
<ul>
<li>easy to use api for value creation and usage</li>
<li>all values require context and their liveness is bound by it</li>
<li>in case of failure, context is marked as such and all operations on the JSON data continue to work in a fashion that they will not cause undefined behavior (however returned values might be sentinel values)</li>
</ul>
<h2>License</h2>
<p>AOJLS is released under BSD 3.0 license. You can freerly use or modify this code, as long as you provide attribution. Author is, however, not liable for any damages for using this code.</p>
<h2>Requirements</h2>
<p>AOJLS only requires C99 and nothing else. From C library, it only requires these headers:</p>
<ul>
<li><code>string.h</code></li>
<li><code>stdio.h</code></li>
<li><code>stdlib.h</code></li>
<li><code>stdbool.h</code></li>
<li><code>setjmp.h</code></li>
<li><code>float.h</code></li>
</ul>
<h2>Example usage</h2>
<h3>Value creation</h3>
<p>For all operations except deserialization (and even there, if we want), you need first to create instance of <code>aojls_ctx_t</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="d2/d44/structaojls__ctx.html">aojls_ctx_t</a>* ctx = <a class="code" href="d3/de7/aojls_8h.html#a3dfc2ca17e6721c9b7d1838f67558c3d">json_make_context</a>(); <span class="comment">// creates new context, or returns NULL on failure</span></div></div><!-- fragment --><p>After creating context, we can create other JSON values:</p>
<div class="fragment"><div class="line"><a class="code" href="da/d65/structjson__object.html">json_object</a>* root = <a class="code" href="d3/de7/aojls_8h.html#adfd03abf089fe7fc634f1fd920bf453f">json_make_object</a>(ctx);             <span class="comment">// creates empty JSON object {}</span></div><div class="line"><a class="code" href="dd/d94/structjson__array.html">json_array</a>* array = <a class="code" href="d3/de7/aojls_8h.html#a008970ae5263c2848e111269a1d63ee2">json_make_array</a>(ctx);              <span class="comment">// creates empty JSON array []</span></div><div class="line"><a class="code" href="dc/d76/structjson__string.html">json_string</a>* <span class="keywordtype">string</span> = <a class="code" href="d3/de7/aojls_8h.html#a75e7eb8c5bc7879a9e82a55a97668b11">json_from_string</a>(ctx, <span class="stringliteral">&quot;foo&quot;</span>);    <span class="comment">// creates JSON string &quot;foo&quot;</span></div><div class="line"><a class="code" href="d1/da3/structjson__number.html">json_number</a>* number = <a class="code" href="d3/de7/aojls_8h.html#a5e4250f65d6a84c15236d709fe190c0b">json_from_number</a>(ctx, 20);       <span class="comment">// creates JSON number 20</span></div><div class="line"><a class="code" href="d0/d62/structjson__boolean.html">json_boolean</a>* <span class="keywordtype">boolean</span> = <a class="code" href="d3/de7/aojls_8h.html#a9618bb0c0021b42276c68e84fbeade13">json_from_boolean</a>(ctx, <span class="keyword">false</span>); <span class="comment">// creates JSON false value </span></div></div><!-- fragment --><h3>Object/Array filling</h3>
<p>Both objects and arrays are one-way mutable. You can push new values into them, but you can't delete values already in them. For objects, you can push in multiple equal keys, and it will produce JSON that can be deserialized by AOJLS, however, might be invalid for other deserializers.</p>
<p>To push new key-value pair into object, use:</p>
<div class="fragment"><div class="line"><a class="code" href="d3/de7/aojls_8h.html#a5ec6d04f090c006b2211a61481e8e4ed">json_object_add</a>(<span class="keywordtype">object</span>, <span class="stringliteral">&quot;foo&quot;</span>, (<a class="code" href="d6/d3e/structjson__value.html">json_value_t</a>*)<a class="code" href="d6/d3e/structjson__value.html">json_value</a>);</div></div><!-- fragment --><p>To push new value into array, use:</p>
<div class="fragment"><div class="line"><a class="code" href="d3/de7/aojls_8h.html#aa3e7163c1f02cf5fd7a9be3890d96680">json_array_add</a>(array, (<a class="code" href="d6/d3e/structjson__value.html">json_value_t</a>*)<a class="code" href="d6/d3e/structjson__value.html">json_value</a>);</div></div><!-- fragment --><p><b>Warning</b>: You may create nested objects with circles, however any attempt to serialize those will end up with stack overflow!</p>
<p>For more operations on objects/arrays see API.</p>
<h3>Serialization</h3>
<p>To serialize some JSON value, simply use <code>aojls_serialize</code>. This function takes <code>json_value_t</code> reference and reference to <code><a class="el" href="d4/d9b/structaojls__serialization__prefs.html" title="Serialization preferences. ">aojls_serialization_prefs</a></code> which may be <code>NULL</code>, in which case default preferences will be used. <code>aojls_serialize</code> returns <code>char*</code> with result, <b>if</b> you use default preferences or you do not specify custom writer. Otherwise, or in case of failure, it returns <code>NULL</code>. If it does return non<code>NULL</code> value, you must deallocate it via <code>free</code> if you are done using it. In case of failure, if you provided preferences, it will also put <code>false</code> into <code><a class="el" href="d4/d9b/structaojls__serialization__prefs.html#adf543fc1483e64ec09308175d69fc4c0">aojls_serialization_prefs.success</a></code>.</p>
<p>Example serialization:</p>
<div class="fragment"><div class="line"><a class="code" href="d4/d9b/structaojls__serialization__prefs.html">aojls_serialization_prefs</a> p;</div><div class="line">p.<a class="code" href="d4/d9b/structaojls__serialization__prefs.html#a27e7525b05afbb419bc49022e6e773d5">eol</a> = NULL;</div><div class="line">p.<a class="code" href="d4/d9b/structaojls__serialization__prefs.html#a694154feddcb9a67ce3e0f0cd8c7c3fd">pretty</a> = <span class="keyword">false</span>;</div><div class="line">p.<a class="code" href="d4/d9b/structaojls__serialization__prefs.html#a03fe5e9e9feef84d50c31468ebef933c">offset_per_level</a> = 4;</div><div class="line">p.<a class="code" href="d4/d9b/structaojls__serialization__prefs.html#a4601671c0714c3a75912f7d323af9c0d">writer</a> = NULL;</div><div class="line">p.<a class="code" href="d4/d9b/structaojls__serialization__prefs.html#a4c9555fbd660a88c3851ed6cd59ecf60">number_formatter</a> = NULL;</div><div class="line"></div><div class="line"><span class="keywordtype">char</span>* result = <a class="code" href="d3/de7/aojls_8h.html#a6ffe0aaf702ae681ffb57ab5c4bbf1e7">aojls_serialize</a>((<a class="code" href="d6/d3e/structjson__value.html">json_value_t</a>*)root, &amp;p);</div></div><!-- fragment --><p>For more options about serialization, see API.</p>
<h3>Deserialization</h3>
<p>If you need to deserialize, you either can provide a context in which new deserialized objects will residue, or deserialization will make new context for you. Use function <code>aojls_deserialize</code>, which takes three parameters, a <code>char*</code> string (does not need to be <code>\0</code> terminated), <code>size_t</code> size of previous string and <code><a class="el" href="d2/db3/structaojls__deserialization__prefs.html" title="Deserialization preferences. ">aojls_deserialization_prefs</a></code>. <code><a class="el" href="d2/db3/structaojls__deserialization__prefs.html" title="Deserialization preferences. ">aojls_deserialization_prefs</a></code> may be <code>NULL</code>, in which case default preferences are used. If you do not specify custom reader, provided string must be valid and length must be correct, otherwise string may be <code>NULL</code>. <code>aojls_deserialize</code> returns reference to <code>aojls_ctx_t</code> (either new, or provided). You can use <code>json_context_get_result</code> to get the resulting deserialized object from this context. In case of failure, <code>json_context_get_result</code> will return NULL and provided preferences, if any, will contain error description.</p>
<p>Example deserialization:</p>
<div class="fragment"><div class="line"><a class="code" href="d2/db3/structaojls__deserialization__prefs.html">aojls_deserialization_prefs</a> dp;</div><div class="line">memset(&amp;dp, 0, <span class="keyword">sizeof</span>(<a class="code" href="d2/db3/structaojls__deserialization__prefs.html">aojls_deserialization_prefs</a>));</div><div class="line"></div><div class="line"><a class="code" href="d2/d44/structaojls__ctx.html">aojls_ctx_t</a>* context = <a class="code" href="d3/de7/aojls_8h.html#a1d9738d92a0fdced18b6adba085f629f">aojls_deserialize</a>(source, strlen(source), &amp;dp);</div><div class="line"><a class="code" href="d6/d3e/structjson__value.html">json_value_t</a>* result = <a class="code" href="d3/de7/aojls_8h.html#aad4a8417ac452ac2c7e8b378d85f6a22">json_context_get_result</a>(context);</div></div><!-- fragment --><p>For more options about deserialization (including providing context yourself), see API.</p>
<h3>Value liveness &amp; memory leak prevention</h3>
<p>All JSON values's memory is tracked by the context they residue in. If you want to free all the memory, simply use <code>json_free_context</code> as in:</p>
<div class="fragment"><div class="line"><a class="code" href="d3/de7/aojls_8h.html#aa4baeef05f36bee83932e512b4dfa079">json_free_context</a>(context); <span class="comment">// after this point, all references to JSON values held in this context</span></div><div class="line">                            <span class="comment">// become invalid and dangling!</span></div></div><!-- fragment --><p>When providing string keys for objects, they are copied upon call and copies are tracked by context, so you can do whatever you want with strings after the call, ie:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>* key = (<span class="keywordtype">char</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)*4); <span class="comment">// allocate 4 bytes</span></div><div class="line">memcpy(key, <span class="stringliteral">&quot;foo&quot;</span>, 4);                     <span class="comment">// copy foo and \0 into key</span></div><div class="line"><a class="code" href="d3/de7/aojls_8h.html#a5ec6d04f090c006b2211a61481e8e4ed">json_object_add</a>(<span class="keywordtype">object</span>, key, <a class="code" href="d6/d3e/structjson__value.html">json_value</a>);  <span class="comment">// at this point, key is copied </span></div><div class="line">                                           <span class="comment">// and stored in the context</span></div><div class="line">free(key);                                 <span class="comment">// valid operation</span></div></div><!-- fragment --><p>String passed into deserialization is not modified and can be freed/modified after deserialization is finished. String returned from serialization needs to be freed by programmer.</p>
<h3>Error checking</h3>
<p>All functions in AOJLS give some way of error checking, either by sentinel value or via function call/validity pass-value. However, you only need to do it when absolutely necessary. All operations must succeed in some way and cannot cause any failure in AOJLS. Therefore, for instance, if you are building some deeply nested JSON value, you can first build that structure completely, and at the end, check whether there were any issues. You can do that via <code>json_context_error_happened</code> at any time. Deserialization will also add error string with explanation in <code><a class="el" href="d2/db3/structaojls__deserialization__prefs.html#a91c606e57b35be9a21c4c408aa452e08">aojls_deserialization_prefs.error</a></code>. Serialization will instead announce success via setting <code><a class="el" href="d4/d9b/structaojls__serialization__prefs.html#adf543fc1483e64ec09308175d69fc4c0">aojls_serialization_prefs.success</a></code> to <code>true</code>.</p>
<h2>API</h2>
<p>Autogenerated documentation is available here:</p>
<h2>Errors &amp; Problems</h2>
<p>If you find any problems or errors, feel free to submit new issue, if there is no such issue already submitted. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
