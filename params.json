{"name":"Aojls","tagline":"\"all other json libraries suck\" - simple to use JSON parser/generator library","body":"# AOJLS\r\n\r\nAOJLS - \"All other JSON libraries suck\" is JSON parsing/generating library that is not aiming for speed or efficiency, but instead aims for programmers comfort. With this in mind, AOJLS is built on these principles:\r\n\r\n1. Creating simple and complex JSON values should be easy and intuitive\r\n2. Programmer should not be bothered to track liveness of all JSON values manually\r\n3. If there is any error when working with JSON values, it should be possible to defer error checking until next logical step\r\n\r\nTo fulfill these principles, AOJLS employs these techniques:\r\n\r\n* easy to use api for value creation and usage\r\n* all values require context and their liveness is bound by it\r\n* in case of failure, context is marked as such and all operations on the JSON data continue to work in a fashion that they will not cause undefined behavior (however returned values might be sentinel values)\r\n\r\n## License\r\n\r\nAOJLS is released under BSD 3.0 license. You can freerly use or modify this code, as long as you provide attribution. Author is, however, not liable for any damages for using this code.\r\n\r\n## Requirements\r\n\r\nAOJLS only requires C99 and nothing else. From C library, it only requires these headers:\r\n\r\n* `string.h`\r\n* `stdio.h`\r\n* `stdlib.h`\r\n* `stdbool.h`\r\n* `setjmp.h`\r\n* `float.h`\r\n\r\n## Example usage\r\n\r\n### Value creation\r\n\r\nFor all operations except deserialization (and even there, if we want), you need first to create instance of `aojls_ctx_t`:\r\n\r\n```c\r\n\taojls_ctx_t* ctx = json_make_context(); // creates new context, or returns NULL on failure\r\n```\r\n\r\nAfter creating context, we can create other JSON values:\r\n\r\n```c\r\n\tjson_object* root = json_make_object(ctx);             // creates empty JSON object {}\r\n\tjson_array* array = json_make_array(ctx);              // creates empty JSON array []\r\n\tjson_string* string = json_from_string(ctx, \"foo\");    // creates JSON string \"foo\"\r\n\tjson_number* number = json_from_number(ctx, 20);       // creates JSON number 20\r\n\tjson_boolean* boolean = json_from_boolean(ctx, false); // creates JSON false value \r\n```\r\n\r\n### Object/Array filling\r\n\r\nBoth objects and arrays are one-way mutable. You can push new values into them, but you can't delete values already in them. For objects, you can push in multiple equal keys, and it will produce JSON that can be deserialized by AOJLS, however, might be invalid for other deserializers.\r\n\r\nTo push new key-value pair into object, use:\r\n\r\n```c\r\n\tjson_object_add(object, \"foo\", (json_value_t*)json_value);\r\n```\r\n\r\nTo push new value into array, use:\r\n\r\n```c\r\n\tjson_array_add(array, (json_value_t*)json_value);\r\n```\r\n\r\n**Warning**: You may create nested objects with circles, however any attempt to serialize those will end up with stack overflow!\r\n\r\nFor more operations on objects/arrays see API.\r\n\r\n### Serialization\r\n\r\nTo serialize some JSON value, simply use `aojls_serialize`. This function takes `json_value_t` reference and reference to `aojls_serialization_prefs` which may be `NULL`, in which case default preferences will be used. `aojls_serialize` returns `char*` with result, **if** you use default preferences or you do not specify custom writer. Otherwise, or in case of failure, it returns `NULL`. If it does return non`NULL` value, you must deallocate it via `free` if you are done using it. In case of failure, if you provided preferences, it will also put `false` into `aojls_serialization_prefs.success`.\r\n\r\nExample serialization:\r\n\r\n```c\r\n    aojls_serialization_prefs p;\r\n\tp.eol = NULL;\r\n\tp.pretty = false;\r\n\tp.offset_per_level = 4;\r\n\tp.writer = NULL;\r\n\tp.number_formatter = NULL;\r\n\r\n\tchar* result = aojls_serialize((json_value_t*)root, &p);\r\n```\r\n\r\nFor more options about serialization, see API.\r\n\r\n### Deserialization\r\n\r\nIf you need to deserialize, you either can provide a context in which new deserialized objects will residue, or deserialization will make new context for you. Use function `aojls_deserialize`, which takes three parameters, a `char*` string (does not need to be `\\0` terminated), `size_t` size of previous string and `aojls_deserialization_prefs`. `aojls_deserialization_prefs` may be `NULL`, in which case default preferences are used. If you do not specify custom reader, provided string must be valid and length must be correct, otherwise string may be `NULL`. `aojls_deserialize` returns reference to `aojls_ctx_t` (either new, or provided). You can use `json_context_get_result` to get the resulting deserialized object from this context. In case of failure, `json_context_get_result` will return NULL and provided preferences, if any, will contain error description. \r\n\r\nExample deserialization:\r\n\r\n```c\r\n\taojls_deserialization_prefs dp;\r\n\tmemset(&dp, 0, sizeof(aojls_deserialization_prefs));\r\n\r\n\taojls_ctx_t* context = aojls_deserialize(source, strlen(source), &dp);\r\n\tjson_value_t* result = json_context_get_result(context);\r\n```\r\n\r\nFor more options about deserialization (including providing context yourself), see API. \r\n\r\n### Value liveness & memory leak prevention\r\n\r\nAll JSON values's memory is tracked by the context they residue in. If you want to free all the memory, simply use `json_free_context` as in:\r\n\r\n```c\r\n\tjson_free_context(context); // after this point, all references to JSON values held in this context\r\n\t\t\t\t\t\t\t\t// become invalid and dangling!\r\n```\r\n\r\nWhen providing string keys for objects, they are copied upon call and copies are tracked by context, so you can do whatever you want with strings after the call, ie:\r\n\r\n```c\r\n\tchar* key = (char*)malloc(sizeof(char)*4); // allocate 4 bytes\r\n\tmemcpy(key, \"foo\", 4);                     // copy foo and \\0 into key\r\n\tjson_object_add(object, key, json_value);  // at this point, key is copied \r\n\t\t\t\t\t\t\t\t\t\t\t   // and stored in the context\r\n\tfree(key);                                 // valid operation\r\n```\r\n\r\nString passed into deserialization is not modified and can be freed/modified after deserialization is finished. String returned from serialization needs to be freed by programmer. \r\n\r\n### Error checking\r\n\r\nAll functions in AOJLS give some way of error checking, either by sentinel value or via function call/validity pass-value. However, you only need to do it when absolutely necessary. All operations must succeed in some way and cannot cause any failure in AOJLS. Therefore, for instance, if you are building some deeply nested JSON value, you can first build that structure completely, and at the end, check whether there were any issues. You can do that via `json_context_error_happened` at any time. Deserialization will also add error string with explanation in `aojls_deserialization_prefs.error`. Serialization will instead announce success via setting `aojls_serialization_prefs.success` to `true`.\r\n\r\n## API\r\nAutogenerated documentation is available here: http://enerccio.github.io/aojls/doc/html/d3/de7/aojls_8h.html\r\n\r\n## Errors & Problems\r\n\r\nIf you find any problems or errors, feel free to submit new issue, if there is no such issue already submitted.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}